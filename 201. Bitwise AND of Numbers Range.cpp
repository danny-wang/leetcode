/**
Given a range [m, n] where 0 <= m <= n <= 2147483647, return the bitwise AND of all numbers in this range, inclusive.
For example, given the range [5, 7], you should return 4.
思路：
考虑数据的二进制形式。
对于整数m到n，在数值连续变化的过程中，它们的某些高位比特是相同的，而只有低位的比特连续变化。
例如：
整数：33，34，35，36
它们的二进制形式是（为了简单，我们假设每个数值有8个bits）：
33 : 00100001
34 : 00100010
35 : 00100011
36 : 00100100
不难看出，它们都具有00100xxx的形式，共同的高位比特是：00100。如果进行按位与运算(&)的话，这些高位是保持不变的。
再看低位（低3位比特）。与运算之后的结果是000。
--------------------------------------------------------------------------------
由上面的分析，可以得到：
为了得到它们与运算的结果，我们只需要找出区间[m, n]范围内所有数值的共同高比特位即可。
又因为m和n是这些数中相差最大的，所以它俩拥有的共同高位比特也是最少的。
所以计算中只需要用m和n即可。
代码如下：
**/
class Solution {
public:
    int rangeBitwiseAnd(int m, int n) {
        int bit=0;
        while(m!=n){
            m>>=1;
            n>>=1;
            bit++;
        }
        return m<<bit;
    }
};